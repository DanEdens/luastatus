#include <assert.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <locale.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>
#include <dlfcn.h>
#include <search.h>
#include <unistd.h>

#include "include/barlib_data.h"
#include "include/plugin_data.h"
#include "include/common.h"

#include "libls/alloc_utils.h"
#include "libls/compdep.h"
#include "libls/errno_utils.h"
#include "libls/getenv_r.h"
#include "libls/lua_utils.h"
#include "libls/sprintf_utils.h"
#include "libls/cstring_utils.h"
#include "libls/vector.h"

#include "config.generated.h"

// Assert that a /pthread_*/ function call was successful.
#define PTH_ASSERT(Expr_) pth_assert_impl(Expr_, #Expr_, __FILE__, __LINE__)

// Logging macros.
#define FATALF(...)    sayf(LUASTATUS_LOG_FATAL,    __VA_ARGS__)
#define ERRF(...)      sayf(LUASTATUS_LOG_ERR,      __VA_ARGS__)
#define WARNF(...)     sayf(LUASTATUS_LOG_WARN,     __VA_ARGS__)
#define INFOF(...)     sayf(LUASTATUS_LOG_INFO,     __VA_ARGS__)
#define VERBOSEF(...)  sayf(LUASTATUS_LOG_VERBOSE,  __VA_ARGS__)
#define DEBUGF(...)    sayf(LUASTATUS_LOG_DEBUG,    __VA_ARGS__)
#define TRACEF(...)    sayf(LUASTATUS_LOG_TRACE,    __VA_ARGS__)

// These ones are implemented as macros so that /pth_assert_impl/ calls receive the correct line
// they are called at.
#define LOCK_B()   PTH_ASSERT(pthread_mutex_lock(&barlib.set_mtx))
#define UNLOCK_B() PTH_ASSERT(pthread_mutex_unlock(&barlib.set_mtx))

#define LOCK_L(W_)   PTH_ASSERT(pthread_mutex_lock(&(W_)->L_mtx))
#define UNLOCK_L(W_) PTH_ASSERT(pthread_mutex_unlock(&(W_)->L_mtx))

#define LOCK_E(W_)   PTH_ASSERT(pthread_mutex_lock(widget_event_L_mtx(W_)))
#define UNLOCK_E(W_) PTH_ASSERT(pthread_mutex_unlock(widget_event_L_mtx(W_)))

typedef struct {
    // The interface loaded from this plugin's shared library file.
    LuastatusPluginIface_v1 iface;

    // An allocated zero-terminated string with plugin name, as specified in widget's
    // /widget.plugin/ string.
    char *name;

    // A handle returned from /dlopen/ for this plugin's shared library file.
    void *dlhandle;
} Plugin;

// If any step of widget's initialization fails, the widget is not removed from the /widgets/
// buffer, but is, instead, unloaded and becomes *stillborn*; barlib's /set_error()/ is called on
// such a widget, and a separate "runner" thread simply does not get spawned for it.
//
// However, barlib's /event_watcher()/ may still report events on such a widget.
// Possible solutions to this are:
//   1. Allow the event watcher's /call_begin/ function (/ew_call_begin/) to return /NULL/ to tell
//      the event watcher that we are not interested in this event, and that it should be skipped.
//      Complicates the API and event watcher's logic.
//   2. Initialize each stillborn widget's /L/ with an empty Lua state, and provide it to the event
//      watcher each time it generates an event on this widget.
//   3. If there is at least one stillborn widget, initialize the *separate state* (see below), and
//      provide /sepstate.L/ to the event watcher. A slight benefit over the second one is that only
//      one extra initialized Lua state is required.
//
// We choose the third one, and thus require stillborn widgets to have:
//   1. /sepstate_event/ field set to /true/ so that /ew_call_begin/ and /ew_call_end/ functions
//      would operate on /sepstate/'s Lua state and mutex guarding it, instead of widget's ones
//      (which are not initialized in the case of a stillborn widget);
//   2. /lref_event/ field set to /LUA_REFNIL/ so that /ew_call_end/ function would simply discard
//      the object generated by barlib's event watcher.

typedef struct {
    // Normal: an initialized plugin.
    // Stillborn: undefined.
    Plugin plugin;

    // Normal: /plugin/'s data for this widget.
    // Stillborn: undefined.
    LuastatusPluginData_v1 data;

    // Normal: this widget's Lua interpreter instance.
    // Stillborn: /NULL/ (used to check if the widget is stillborn).
    lua_State *L;

    // Normal: a mutex guarding /L/.
    // Stillborn: undefined.
    pthread_mutex_t L_mtx;

    // Normal: Lua reference (in /L/'s registry) to this widget's /widget.cb/ function.
    // Stillborn: undefined.
    int lref_cb;

    // Normal:
    //   if /sepstate_event/ is false, Lua reference (in /L/'s registry) to this widget's
    //     /widget.event/ function (is /LUA_REFNIL/ if the latter is /nil/);
    //   if /sepstate_event/ is true, Lua reference (in /sepstate.L/'s registry) to the compiled
    //      /widget.event/ function of this widget.
    // Stillborn: /LUA_REFNIL/.
    int lref_event;

    // Normal: whether /lref_event/ is a reference in /sepstate.L/'s registry, as opposed to
    // /L/'s one.
    // Stillborn: /true/.
    bool sepstate_event;

    // Normal: an allocated zero-terminated string with widget's file name.
    // Stillborn: undefined.
    char *filename;
} Widget;

// Current log level. May only be changed once, when parsing command-line arguments.
static int loglevel = LUASTATUS_LOG_INFO;

static struct {
    // The interface loaded from this barlib's shared library file.
    LuastatusBarlibIface_v1 iface;

    // This barlib's data.
    LuastatusBarlibData_v1 data;

    // A mutex guarding calls to /iface.set()/ and /iface.set_error()/.
    pthread_mutex_t set_mtx;

    // A handle required from /dlopen/ for this barlib's shared library file.
    void *dlhandle;
} barlib;

// These two are initially (explicitly) set to /NULL/ and /0/ correspondingly, so that the
// destruction function (/widgets_destroy()/) can be invoked at any time (that is, before or after
// their initialization with actual values, not in the middle of it).
//
// This requires a little care with initialization; /widgets_init()/ should be used for it.
static Widget *widgets = NULL;
static size_t nwidgets = 0;

// This "separate state" thing serves two purposes:
//   1. If a widget has a /widget.event/ variable of string type, it is compiled in /sepstate.L/ Lua
//      interpreter instance as a function; a reference to it is stored in that widget's
//      /lref_event/ field; and the /sepstate_event/ field of that widget is set to /true/.
//   2. As has been already described above, /sepstate.L/ is provided to barlib's /event_watcher()/
//      each time it attempts to generate an event on a stillborn widget; the event object is then
//      simply discarded.
static struct {
    // Separate state's Lua interpreter instance. Initially is (explicitly) set to /NULL/, which
    // indicates that the separate state was not initialized yet.
    lua_State *L;

    // A mutex guarding /L/.
    pthread_mutex_t L_mtx;
} sepstate = {NULL};

// See DOCS/design/map_get.md
//
// Basically, it is a string-to-pointer mapping used by plugins and barlibs for synchronization.
//
// We use the search tree interface from /<search.h>/, which, in any sane implementation, should be
// of logarithmic time complexity for search, insert and delete operations.

// A structure we store in the nodes of the tree.
typedef struct {
    // The pointer value of this entry.
    void *value;

    // A flexible array member containing the zero-terminated key string of this entry.
    char key[];
} MapEntry;

// An (opaque) pointer to the root node of the search tree. A /NULL/ represents an empty tree.
static void *map_root = NULL;

// An implementation part for the /PTH_ASSERT/ macro.
static
void
pth_assert_impl(int ret, const char *expr, const char *file, int line)
{
    if (ret) {
        LS_WITH_ERRSTR(s, ret,
            fprintf(stderr, "PTH_ASSERT(%s) failed at %s:%d\nReason: %s\n", expr, file, line, s);
        );
        abort();
    }
}

// This function exists because /dlerror()/ may return /NULL/ even if /dlsym()/ returned /NULL/.
static inline
const char *
safe_dlerror(void)
{
    const char *err = dlerror();
    return err ? err : "(no error, but the symbol is NULL)";
}

#define XPAND_LOGLEVELS() \
    X(LUASTATUS_LOG_FATAL,   "fatal") \
    X(LUASTATUS_LOG_ERR,     "error") \
    X(LUASTATUS_LOG_WARN,    "warning") \
    X(LUASTATUS_LOG_INFO,    "info") \
    X(LUASTATUS_LOG_VERBOSE, "verbose") \
    X(LUASTATUS_LOG_DEBUG,   "debug") \
    X(LUASTATUS_LOG_TRACE,   "trace") \
    /* end of the list */

// Returns a name of the given log level. If /level/ is not a correct log level, the behaviour is
// undefined.
static
const char *
loglevel_tostr(int level)
{
    switch (level) {
#define X(Level_, Name_) case Level_: return Name_;
    XPAND_LOGLEVELS()
#undef X
    }
    LS_UNREACHABLE();
}

// Returns a log level number by its name /str/, or returns /LUASTATUS_LOG_LAST/ if no such log
// level was found.
static
int
loglevel_fromstr(const char *str)
{
#define X(Level_, Name_) \
    if (strcmp(str, Name_) == 0) { \
        return Level_; \
    }
    XPAND_LOGLEVELS()
#undef X
    return LUASTATUS_LOG_LAST;
}
#undef XPAND_LOGLEVELS

// The generic logging function: generates a log message with level /level/ from a given /subsystem/
// (either a plugin or a barlib name; or /NULL/, which means the message is from the luastatus
// program itself) using the format string /fmt/ and variable arguments supplied as /vl/, as if with
// /vsnprintf(<unspecified>, fmt, vl)/.
static
void
common_vsayf(int level, const char *subsystem, const char *fmt, va_list vl)
{
    if (level > loglevel) {
        return;
    }

    char buf[1024];
    if (vsnprintf(buf, sizeof(buf), fmt, vl) < 0) {
        ls_strlcpy(buf, "(vsnprintf failed)", sizeof(buf));
    }

    if (subsystem) {
        fprintf(stderr, "luastatus: (%s) %s: %s\n", subsystem, loglevel_tostr(level), buf);
    } else {
        fprintf(stderr, "luastatus: %s: %s\n", loglevel_tostr(level), buf);
    }
}

// The "internal" logging function: generates a log message from the luastatus program itself with
// level /level/ using the format string /fmt/ and the variable arguments supplied as /.../, as if
// with /vsnprintf(<unspecified>, fmt, <... variable arguments>)/.
static inline LS_ATTR_PRINTF(2, 3)
void
sayf(int level, const char *fmt, ...)
{
    va_list vl;
    va_start(vl, fmt);
    common_vsayf(level, NULL, fmt, vl);
    va_end(vl);
}

// An "external" logging function: generates a log message from the subsystem denoted by /userdata/
// with level /level/ using the format string /fmt/ and the variable arguments supplied as /.../, as
// if with /vsnprintf(<unspecified>, fmt, <... variable arguments>/.
static
void
external_sayf(void *userdata, int level, const char *fmt, ...)
{
    va_list vl;
    va_start(vl, fmt);
    if (userdata) {
        Widget *w = userdata;
        char who[1024];
        snprintf(who, sizeof(who), "%s@%s", w->plugin.name, w->filename);
        common_vsayf(level, who, fmt, vl);
    } else {
        common_vsayf(level, "barlib", fmt, vl);
    }
    va_end(vl);
}

// Compares two map entries by key.
static
int
map_entry_cmp(const void *a, const void *b)
{
    return strcmp(((const MapEntry *) a)->key, ((const MapEntry *) b)->key);
}

// Returns a pointer to the value of the entry with key /key/.
static
void **
map_get(void *userdata, const char *key)
{
    TRACEF("map_get(userdata=%p, key='%s')", userdata, key);

    const size_t nkey = strlen(key);
    MapEntry *alloc = ls_xmalloc(sizeof(MapEntry) + nkey + 1, 1);
    alloc->value = NULL;
    memcpy(alloc->key, key, nkey + 1);

    void *node = tsearch(alloc, &map_root, map_entry_cmp);
    if (!node) {
        ls_oom();
    }
    MapEntry *in_tree = *(MapEntry **) node;
    if (in_tree != alloc) {
        free(alloc);
    }
    return &in_tree->value;
}

// Destroys the map.
static
void
map_destroy(void)
{
    while (map_root) {
        MapEntry *ent = *(MapEntry **) map_root;
        tdelete(ent, &map_root, map_entry_cmp);
        free(ent);
    }
}

// Loads /barlib/ from a file /filename/ and initializes with options /opts/ and the number of
// widgets /nwidgets/ (a global variable).
static
bool
barlib_init(const char *filename, const char *const *opts)
{
    DEBUGF("initializing barlib from file '%s', opts=[", filename);
    for (const char *const *s = opts; *s; ++s) {
        DEBUGF(" '%s',", *s);
    }
    DEBUGF("]");

    barlib.dlhandle = NULL; // this is an indicator whether or not to call /dlclose()/ on error.

    (void) dlerror(); // clear last error
    if (!(barlib.dlhandle = dlopen(filename, RTLD_NOW | RTLD_LOCAL))) {
        ERRF("dlopen: %s: %s", filename, safe_dlerror());
        goto error;
    }
    int *p_lua_ver = dlsym(barlib.dlhandle, "LUASTATUS_BARLIB_LUA_VERSION_NUM");
    if (!p_lua_ver) {
        ERRF("dlsym: LUASTATUS_BARLIB_LUA_VERSION_NUM: %s", safe_dlerror());
        goto error;
    }
    if (*p_lua_ver != LUA_VERSION_NUM) {
        ERRF("barlib '%s' was compiled with LUA_VERSION_NUM=%d and luastatus with %d",
            filename, *p_lua_ver, LUA_VERSION_NUM);
        goto error;
    }
    LuastatusBarlibIface_v1 *p_iface = dlsym(barlib.dlhandle, "luastatus_barlib_iface_v1");
    if (!p_iface) {
        ERRF("dlsym: luastatus_barlib_iface_v1: %s", safe_dlerror());
        goto error;
    }
    barlib.iface = *p_iface;
    barlib.data = (LuastatusBarlibData_v1) {
        .userdata = NULL,
        .sayf = external_sayf,
        .map_get = map_get,
    };

    if (barlib.iface.init(&barlib.data, opts, nwidgets) == LUASTATUS_ERR) {
        ERRF("barlib's init() failed");
        goto error;
    }

    PTH_ASSERT(pthread_mutex_init(&barlib.set_mtx, NULL));

    DEBUGF("barlib successfully initialized");
    return true;

error:
    if (barlib.dlhandle) {
        dlclose(barlib.dlhandle);
    }
    return false;
}

// The result is same to calling /barlib_init(<filename>, opts)/, where /<filename>/ is the file
// name guessed for name /name/.
static
bool
barlib_init_by_name(const char *name, const char *const *opts)
{
    if ((strchr(name, '/'))) {
        return barlib_init(name, opts);
    } else {
        char *filename = ls_xasprintf("%s/%s.so", LUASTATUS_BARLIBS_DIR, name);
        bool r = barlib_init(filename, opts);
        free(filename);
        return r;
    }
}

// Destroys /barlib/.
static
void
barlib_destroy(void)
{
    barlib.iface.destroy(&barlib.data);
    dlclose(barlib.dlhandle);
    PTH_ASSERT(pthread_mutex_destroy(&barlib.set_mtx));
}

// Loads a plugin /p/ with name /name/ from a file /filename/.
static
bool
plugin_load(Plugin *p, const char *filename, const char *name)
{
    DEBUGF("loading plugin from file '%s'", filename);

    p->dlhandle = NULL; // this is an indicator whether or not to call /dlclose()/ on error.

    (void) dlerror(); // clear last error
    if (!(p->dlhandle = dlopen(filename, RTLD_NOW | RTLD_LOCAL))) {
        ERRF("dlopen: %s: %s", filename, safe_dlerror());
        goto error;
    }
    int *p_lua_ver = dlsym(p->dlhandle, "LUASTATUS_PLUGIN_LUA_VERSION_NUM");
    if (!p_lua_ver) {
        ERRF("dlsym: LUASTATUS_PLUGIN_LUA_VERSION_NUM: %s", safe_dlerror());
        goto error;
    }
    if (*p_lua_ver != LUA_VERSION_NUM) {
        ERRF("plugin '%s' was compiled with LUA_VERSION_NUM=%d and luastatus with %d",
            filename, *p_lua_ver, LUA_VERSION_NUM);
        goto error;
    }
    LuastatusPluginIface_v1 *p_iface = dlsym(p->dlhandle, "luastatus_plugin_iface_v1");
    if (!p_iface) {
        ERRF("dlsym: luastatus_plugin_iface_v1: %s", safe_dlerror());
        goto error;
    }
    p->iface = *p_iface;

    p->name = ls_xstrdup(name);
    DEBUGF("plugin successfully loaded");
    return true;

error:
    if (p->dlhandle) {
        dlclose(p->dlhandle);
    }
    return false;
}

// The result is same to calling /plugin_load(p, <filename>, name)/, where /<filename>/ is the file
// name guessed for name /name/.
static
bool
plugin_load_by_name(Plugin *p, const char *name)
{
    if ((strchr(name, '/'))) {
        return plugin_load(p, name, name);
    } else {
        char *filename = ls_xasprintf("%s/%s.so", LUASTATUS_PLUGINS_DIR, name);
        bool r = plugin_load(p, filename, name);
        free(filename);
        return r;
    }
}

// Unloads a plugin /p/.
static
void
plugin_unload(Plugin *p)
{
    free(p->name);
    dlclose(p->dlhandle);
}

// Checks a /lua_*/ call that returns a /LUA_*/ error code, performed on a Lua interpreter instance
// /L/. /ret/ is the return value of the call.
//
// If /ret/ is /LUA_OK/, returns /true/; otherwise, logs the error and returns /false/.
static
bool
check_lua_call(lua_State *L, int ret)
{
    const char *prefix;
    switch (ret) {
    case LUA_OK:
        return true;
    case LUA_ERRRUN:
    case LUA_ERRSYNTAX:
    case LUA_ERRMEM:  // Lua itself produces a meaningful error message in this case
    case LUA_ERRFILE: // ditto
        prefix = "(lua) ";
        break;
    case LUA_ERRERR:
        prefix = "(lua) error while running error handler: ";
        break;
#ifdef LUA_ERRGCMM
    // first introduced in Lua 5.2
    case LUA_ERRGCMM:
        prefix = "(lua) error while running __gc metamethod: ";
        break;
#endif
    default:
        prefix = "unknown Lua error code (please report!), message is: ";
    }
    const char *msg = lua_tostring(L, -1);
    if (!msg) {
        msg = "(error object can't be converted to string)";
    }
    ERRF("%s%s", prefix, msg);
    lua_pop(L, 1);
    return false;
}

// Replacement for Lua's /os.exit()/: a simple /exit()/ used by Lua is not thread-safe in Linux.
static
int
l_os_exit(lua_State *L)
{
    int code = luaL_optinteger(L, 1, /*default value*/ EXIT_SUCCESS);
    fflush(NULL);
    _exit(code);
}

// Replacement for Lua's /os.getenv()/: a simple /getenv()/ used by Lua is not guaranteed by POSIX
// to be thread-safe.
static
int
l_os_getenv(lua_State *L)
{
    const char *r = ls_getenv_r(luaL_checkstring(L, 1));
    if (r) {
        lua_pushstring(L, r);
    } else {
        lua_pushnil(L);
    }
    return 1;
}

// Replacement for Lua's /os.setlocale()/: this thing is inherently thread-unsafe.
static
int
l_os_setlocale(lua_State *L)
{
    lua_pushnil(L);
    return 1;
}

// Replaces some of the functions in /L/'s Lua libraries with their thread-safe counterparts.
void
inject_libs(lua_State *L)
{
#define REG(Name_, Ptr_) \
    do { \
        /* L: table */ \
        lua_pushcfunction(L, Ptr_); /* L: table ptr */ \
        ls_lua_rawsetf(L, Name_); /* L: table */ \
    } while (0)

    lua_getglobal(L, "os"); // L: os
    REG("exit", l_os_exit);
    REG("getenv", l_os_getenv);
    REG("setlocale", l_os_setlocale);
    lua_pop(L, 1); // L: -
#undef REG
}

// Registers /barlib/'s function at /L/.
// If /w/ is not /NULL/, registers /w/'s plugin's functions at /L/.
static
void
register_funcs(lua_State *L, Widget *w)
{
    lua_newtable(L); // L: table
    if (barlib.iface.register_funcs) {
        lua_newtable(L); // L: table table
        barlib.iface.register_funcs(&barlib.data, L); // L: table table
        assert(lua_gettop(L) == 2);
        ls_lua_rawsetf(L, "barlib"); // L: table
    }
    if (w && w->plugin.iface.register_funcs) {
        lua_newtable(L); // L: table table
        w->plugin.iface.register_funcs(&w->data, L); // L: table table
        assert(lua_gettop(L) == 2);
        ls_lua_rawsetf(L, "plugin"); // L: table
    }
    lua_setglobal(L, "luastatus"); // L: -
}

// Initializes, if not already initialized, the separate state.
static
void
sepstate_maybe_init(void)
{
    if (sepstate.L) {
        // already initialized
        return;
    }
    if (!(sepstate.L = luaL_newstate())) {
        ls_oom();
    }
    luaL_openlibs(sepstate.L);
    inject_libs(sepstate.L);
    PTH_ASSERT(pthread_mutex_init(&sepstate.L_mtx, NULL));
}

// Destroys, if needed, the separate state.
static
void
sepstate_maybe_destroy(void)
{
    if (!sepstate.L) {
        // hasn't been initialized
        return;
    }
    lua_close(sepstate.L);
    PTH_ASSERT(pthread_mutex_destroy(&sepstate.L_mtx));
}

// Inspects the 'plugin' field of /w/'s /widget/ table, which is assumed to be on top of /w.L/'s
// stack (which is unchanged on return).
static
bool
widget_init_inspect_plugin(Widget *w)
{
    lua_State *L = w->L;
    // L: widget
    ls_lua_rawgetf(L, "plugin"); // L: widget plugin
    if (!lua_isstring(L, -1)) {
        ERRF("'widget.plugin': expected string, found %s", luaL_typename(L, -1));
        return false;
    }
    if (!plugin_load_by_name(&w->plugin, lua_tostring(L, -1))) {
        ERRF("cannot load plugin '%s'", lua_tostring(L, -1));
        return false;
    }
    lua_pop(L, 1); // L: widget
    return true;
}

// As /widget_init_inspect_plugin/, but inspects the 'cb' field instead.
static
bool
widget_init_inspect_cb(Widget *w)
{
    lua_State *L = w->L;
    // L: widget
    ls_lua_rawgetf(L, "cb"); // L: widget plugin
    if (!lua_isfunction(L, -1)) {
        ERRF("'widget.cb': expected function, found %s", luaL_typename(L, -1));
        return false;
    }
    w->lref_cb = luaL_ref(L, LUA_REGISTRYINDEX); // L: widget
    return true;
}

// As /widget_init_inspect_plugin/, but inspects the 'event' field instead.
static
bool
widget_init_inspect_event(Widget *w, const char *filename)
{
    lua_State *L = w->L;
    // L: widget
    ls_lua_rawgetf(L, "event"); // L: widget event
    switch (lua_type(L, -1)) {
    case LUA_TNIL:
    case LUA_TFUNCTION:
        w->lref_event = luaL_ref(L, LUA_REGISTRYINDEX); // L: widget
        w->sepstate_event = false;
        return true;
    case LUA_TSTRING:
        {
            sepstate_maybe_init();
            size_t ncode;
            const char *code = lua_tolstring(w->L, -1, &ncode);
            char *chunkname = ls_xasprintf("widget.event of %s", filename);
            bool r = check_lua_call(sepstate.L, luaL_loadbuffer(sepstate.L,
                code, ncode, chunkname));
            free(chunkname);
            if (!r) {
                return false;
            }
            // sepstate.L: chunk
            w->lref_event = luaL_ref(sepstate.L, LUA_REGISTRYINDEX); // sepstate.L: -
            w->sepstate_event = true;
            lua_pop(L, 1); // L: widget
            return true;
        }
    default:
        ERRF("'widget.event': expected function, nil, or string, found %s", luaL_typename(L, -1));
        return false;
    }
}

// Inspects the 'opts' field of /w/'s /widget/ table, which is assumed to be on top of /w.L/'s
// stack.
// Additionally, pushes the 'opts' field to /w.L/'s stack.
static
bool
widget_init_inspect_keep_opts(Widget *w)
{
    lua_State *L = w->L;
    ls_lua_rawgetf(L, "opts"); // L: widget opts
    switch (lua_type(L, -1)) {
    case LUA_TTABLE:
        return true;
    case LUA_TNIL:
        lua_pop(L, 1); // L: widget
        lua_newtable(L); // L: widget table
        return true;
    default:
        ERRF("'widget.opts': expected function or nil, found %s", luaL_typename(L, -1));
        return false;
    }
}

// Initializes widget /w/ from file /filename/.
static
bool
widget_init(Widget *w, const char *filename)
{
    DEBUGF("initializing widget '%s'", filename);

    lua_State *L = w->L = luaL_newstate();
    PTH_ASSERT(pthread_mutex_init(&w->L_mtx, NULL));
    w->filename = ls_xstrdup(filename);
    bool plugin_loaded = false;

    if (!L) {
        ls_oom();
    }

    luaL_openlibs(L);
    // L: -
    inject_libs(L); // L: -

    DEBUGF("running file '%s'", filename);
    if (!check_lua_call(L, luaL_loadfile(L, filename)) || // L: chunk
        !check_lua_call(L, lua_pcall(L, 0, 0, 0)))
    {
        goto error;
    }
    // L: -

    lua_getglobal(L, "widget"); // L: widget
    if (!lua_istable(L, -1)) {
        ERRF("'widget': expected table, found %s", luaL_typename(L, -1));
        goto error;
    }

    if (!widget_init_inspect_plugin(w)) {
        goto error;
    }
    plugin_loaded = true;
    if (!widget_init_inspect_cb(w) ||
        !widget_init_inspect_event(w, filename) ||
        !widget_init_inspect_keep_opts(w))
    {
        goto error;
    }
    // L: widget opts

    w->data = (LuastatusPluginData_v1) {
        .userdata = w,
        .sayf = external_sayf,
        .map_get = map_get,
    };

    if (w->plugin.iface.init(&w->data, L) == LUASTATUS_ERR) {
        ERRF("plugin's init() failed");
        goto error;
    }
    assert(lua_gettop(L) == 2); // L: widget opts
    lua_pop(L, 2); // L: -

    DEBUGF("widget successfully initialized");
    return true;

error:
    lua_close(L);
    PTH_ASSERT(pthread_mutex_destroy(&w->L_mtx));
    free(w->filename);
    if (plugin_loaded) {
        plugin_unload(&w->plugin);
    }
    return false;
}

// Initializes widget /w/ and makes it stillborn.
static
void
widget_init_stillborn(Widget *w)
{
    sepstate_maybe_init();
    w->L = NULL;
    w->lref_event = LUA_REFNIL;
    w->sepstate_event = true;
}

// Checks whether a widget /w/ is stillborn.
static inline
bool
widget_is_stillborn(Widget *w)
{
    return !w->L;
}

// Returns the Lua interpreter instance for the /widget.event/ function of a widget /w/.
static inline
lua_State *
widget_event_lua_state(Widget *w)
{
    return w->sepstate_event ? sepstate.L : w->L;
}

// Returns a pointer to the mutex guarding the Lua interpreter instance for the /widget.event/
// function of a widget /w/.
static inline
pthread_mutex_t *
widget_event_L_mtx(Widget *w)
{
    return w->sepstate_event ? &sepstate.L_mtx : &w->L_mtx;
}

// Returns the index of a widget /w/.
static inline
size_t
widget_index(Widget *w)
{
    return w - widgets;
}

// Destroys a (possibly stillborn) widget /w/.
static
void
widget_destroy(Widget *w)
{
    if (!widget_is_stillborn(w)) {
        w->plugin.iface.destroy(&w->data);
        plugin_unload(&w->plugin);
        lua_close(w->L);
        PTH_ASSERT(pthread_mutex_destroy(&w->L_mtx));
        free(w->filename);
    }
}

// Initializes the /widgets/ and /nwidgets/ global variables from the given list of file names:
// sets /nwidgets/, allocates /widgets/, initialized all the widgets, and makes ones whose
// initialization failed stillborn.
static
void
widgets_init(char *const *filenames, size_t nfilenames)
{
    nwidgets = nfilenames;
    widgets = LS_XNEW(Widget, nwidgets);
    for (size_t i = 0; i < nwidgets; ++i) {
        if (!widget_init(&widgets[i], filenames[i])) {
            ERRF("cannot load widget '%s'", filenames[i]);
            widget_init_stillborn(&widgets[i]);
        }
    }
}

// Destroys the widgets.
static
void
widgets_destroy(void)
{
    for (size_t i = 0; i < nwidgets; ++i) {
        widget_destroy(&widgets[i]);
    }
    free(widgets);
}

// Should be invoked whenever the barlib reports a fatal error.
static LS_ATTR_NORETURN
void
fatal_error_reported(void)
{
    fflush(NULL);
    _exit(EXIT_FAILURE);
}

// Invokes /barlib/'s /set_error()/ method on a widget with index /widget_idx/ and performs all the
// error-checking required.
//
// Does not do any locking/unlocking.
static
void
set_error_unlocked(size_t widget_idx)
{
    if (barlib.iface.set_error(&barlib.data, widget_idx) == LUASTATUS_ERR) {
        FATALF("barlib's set_error() reported fatal error");
        fatal_error_reported();
    }
}

static
lua_State *
plugin_call_begin(void *userdata)
{
    TRACEF("plugin_call_begin(userdata=%p)", userdata);

    Widget *w = userdata;
    LOCK_L(w);

    lua_State *L = w->L;
    assert(lua_gettop(L) == 0); // w->L: -
    lua_rawgeti(L, LUA_REGISTRYINDEX, w->lref_cb); // w->L: cb
    return L;
}

static
void
plugin_call_end(void *userdata)
{
    TRACEF("plugin_call_end(userdata=%p)", userdata);

    Widget *w = userdata;
    lua_State *L = w->L;
    assert(lua_gettop(L) == 2); // L: cb data
    bool r = check_lua_call(L, lua_pcall(L, 1, 1, 0));
    LOCK_B();
    size_t widget_idx = widget_index(w);
    if (r) {
        // L: result
        switch (barlib.iface.set(&barlib.data, L, widget_idx)) {
        case LUASTATUS_OK:
            // L: result
            break;
        case LUASTATUS_NONFATAL_ERR:
            // L: ?
            set_error_unlocked(widget_idx);
            break;
        case LUASTATUS_ERR:
            // L: ?
            FATALF("barlib's set() reported fatal error");
            fatal_error_reported();
            break;
        }
        lua_settop(L, 0); // L: -
    } else {
        // L: -
        set_error_unlocked(widget_idx);
    }
    UNLOCK_B();
    UNLOCK_L(w);
}

static
void
plugin_call_cancel(void *userdata)
{
    TRACEF("plugin_call_cancel(userdata=%p)", userdata);

    Widget *w = userdata;
    lua_settop(w->L, 0); // w->L: -
    UNLOCK_L(w);
}

static
lua_State *
ew_call_begin(LS_ATTR_UNUSED_ARG void *userdata, size_t widget_idx)
{
    TRACEF("ew_call_begin(userdata=%p, widget_idx=%zu)", userdata, widget_idx);

    assert(widget_idx < nwidgets);
    Widget *w = &widgets[widget_idx];
    LOCK_E(w);

    lua_State *L = widget_event_lua_state(w);
    assert(lua_gettop(L) == 0); // L: -
    lua_rawgeti(L, LUA_REGISTRYINDEX, w->lref_event); // L: event
    return L;
}

static
void
ew_call_end(void *userdata, size_t widget_idx)
{
    TRACEF("ew_call_end(userdata=%p, widget_idx=%zu)", userdata, widget_idx);

    assert(widget_idx < nwidgets);
    Widget *w = &widgets[widget_idx];
    lua_State *L = widget_event_lua_state(w);
    assert(lua_gettop(L) == 2); // L: event arg
    if (w->lref_event == LUA_REFNIL) {
        lua_pop(L, 2); // L: -
    } else {
        if (!check_lua_call(L, lua_pcall(L, 1, 0, 0))) {
            // L: -
            LOCK_B();
            set_error_unlocked(widget_idx);
            UNLOCK_B();
        }
        // L: -
    }
    UNLOCK_E(w);
}

static
void
ew_call_cancel(void *userdata, size_t widget_idx)
{
    TRACEF("ew_call_cancel(userdata=%p, widget_idx=%zu)", userdata, widget_idx);

    assert(widget_idx < nwidgets);
    Widget *w = &widgets[widget_idx];
    lua_State *L = widget_event_lua_state(w);
    lua_settop(L, 0); // L: -
    UNLOCK_E(w);
}

// Each thread spawned for a widget runs this function. /arg/ is a pointer to the widget.
static
void *
widget_thread(void *arg)
{
    Widget *w = arg;
    DEBUGF("thread for widget '%s' is running", w->filename);

    w->plugin.iface.run(&w->data, (LuastatusPluginRunFuncs_v1) {
        .call_begin  = plugin_call_begin,
        .call_end    = plugin_call_end,
        .call_cancel = plugin_call_cancel,
    });
    WARNF("plugin's run() for widget '%s' has returned", w->filename);

    LOCK_B();
    set_error_unlocked(widget_index(w));
    UNLOCK_B();

    return NULL;
}

static
bool
prepare_stdio(void)
{
    // We rely on that /*printf/ functions produce numbers in C locale.
    if (setlocale(LC_NUMERIC, "C") == NULL) {
        fprintf(stderr, "luastatus: FATAL: setlocale failed\n");
        return false;
    }
    return true;
}

static
void
ignore_signal(LS_ATTR_UNUSED_ARG int signo)
{
}

static
bool
prepare_signals(void)
{
    struct sigaction sa = {.sa_flags = SA_RESTART};
    if (sigemptyset(&sa.sa_mask) < 0) {
        LS_WITH_ERRSTR(s, errno,
            fprintf(stderr, "luastatus: FATAL: sigemptyset: %s", s);
        );
        return false;
    }
#define HANDLE(SigNo_) \
    do { \
        if (sigaction(SigNo_, &sa, NULL) < 0) { \
            LS_WITH_ERRSTR(s, errno, \
                fprintf(stderr, "luastatus: WARNING: sigaction: %s: %s", #SigNo_, s); \
            ); \
        } \
    } while (0)

    // We do not want to terminate on a write to a dead pipe.
    sa.sa_handler = ignore_signal;
    HANDLE(SIGPIPE);

    // We do this to ensure SA_RESTART is set for these.
    sa.sa_handler = SIG_DFL;
    HANDLE(SIGCHLD);
    HANDLE(SIGURG);

#undef HANDLE
    return true;
}

static
void
print_usage(void)
{
    fprintf(stderr, "USAGE: luastatus -b barlib [-B barlib_option [-B ...]] [-l loglevel] [-e] "
                    "widget.lua [widget2.lua ...]\n"
                    "       luastatus -v\n"
                    "See luastatus(1) for more information.\n");
}

int
main(int argc, char **argv)
{
    int ret = EXIT_FAILURE;
    char *barlib_name = NULL;
    LS_VECTOR_OF(const char *) barlib_args = LS_VECTOR_NEW();
    bool no_hang = false;
    LS_VECTOR_OF(pthread_t) threads = LS_VECTOR_NEW();
    bool barlib_inited = false;

    // Parse the arguments.

    for (int c; (c = getopt(argc, argv, "b:B:l:ev")) != -1;) {
        switch (c) {
        case 'b':
            barlib_name = optarg;
            break;
        case 'B':
            LS_VECTOR_PUSH(barlib_args, optarg);
            break;
        case 'l':
            if ((loglevel = loglevel_fromstr(optarg)) == LUASTATUS_LOG_LAST) {
                fprintf(stderr, "Unknown log level name '%s'.\n", optarg);
                print_usage();
                goto cleanup;
            }
            break;
        case 'e':
            no_hang = true;
            break;
        case 'v':
            fprintf(stderr, "This is luastatus %s.\n", LUASTATUS_VERSION);
            goto cleanup;
        case '?':
            print_usage();
            goto cleanup;
        default:
            LS_UNREACHABLE();
        }
    }

    if (!barlib_name) {
        fprintf(stderr, "Barlib was not specified.");
        print_usage();
        goto cleanup;
    }

    // Prepare.

    if (!prepare_stdio() || !prepare_signals()) {
        goto cleanup;
    }

    // Initialize the widgets (now, proper logging can be used).

    widgets_init(argv + optind, argc - optind);

    TRACEF("nwidgets = %zu, widgets = %p, sizeof(Widget) = %d",
        nwidgets, (void *) widgets, (int) sizeof(Widget));

    if (!nwidgets) {
        WARNF("no widgets specified (see luastatus(1) for usage info)");
    }

    // Initialize the barlib.

    LS_VECTOR_PUSH(barlib_args, NULL);
    if (!barlib_init_by_name(barlib_name, barlib_args.data)) {
        FATALF("cannot load barlib '%s'", barlib_name);
        goto cleanup;
    }
    barlib_inited = true;

    // register barlib's function at the separate state, if we are going to use it.
    if (sepstate.L) {
        register_funcs(sepstate.L, NULL);
    }

    // Spawn a thread for each successfully initialized widget, call /barlib/'s /set_error()/ method
    // on each widget whose initialization has failed.

    LS_VECTOR_RESERVE(threads, nwidgets);
    for (size_t i = 0; i < nwidgets; ++i) {
        Widget *w = &widgets[i];
        if (widget_is_stillborn(w)) {
            LOCK_B();
            set_error_unlocked(i);
            UNLOCK_B();
        } else {
            register_funcs(w->L, w);
            pthread_t t;
            PTH_ASSERT(pthread_create(&t, NULL, widget_thread, w));
            LS_VECTOR_PUSH(threads, t);
        }
    }

    // Run /barlib/'s event watcher, if present.

    if (barlib.iface.event_watcher) {
        if (barlib.iface.event_watcher(&barlib.data, (LuastatusBarlibEWFuncs_v1) {
                .call_begin  = ew_call_begin,
                .call_end    = ew_call_end,
                .call_cancel = ew_call_cancel,
            }) == LUASTATUS_ERR)
        {
            FATALF("barlib's event_watcher() reported fatal error");
            fatal_error_reported();
        }
    }

    // Join the widget threads.

    DEBUGF("joining all the widget threads");
    for (size_t i = 0; i < threads.size; ++i) {
        PTH_ASSERT(pthread_join(threads.data[i], NULL));
    }

    // Either hang or exit.

    WARNF("all plugins' run() and barlib's event_watcher() have returned");
    if (no_hang) {
        INFOF("-e passed, exiting");
        ret = EXIT_SUCCESS;
    } else {
        INFOF("since -e not passed, will hang now");
        while (1) {
            pause();
        }
    }

cleanup:
    // Let us please valgrind.
    LS_VECTOR_FREE(barlib_args);
    LS_VECTOR_FREE(threads);
    widgets_destroy();
    if (barlib_inited) {
        barlib_destroy();
    }
    sepstate_maybe_destroy();
    map_destroy();
    return ret;
}
